user www-data;
worker_processes auto;
pid /run/nginx.pid;
include /etc/nginx/modules-enabled/*.conf;

events {
        worker_connections 1024;
        # multi_accept on;
}

rtmp {
    server {
        listen 1935; # Setting RTMP Port
        chunk_size 4000;
        # Seeting APP items of the RTMP，the URL of the RTMP is: rtmp://ip:1935/live
        # It's the input for the live broadcast
        application live {
            live on; # allow input
            # When receive the RTMP streaming，execute FFMPEG transform command，the $app parameter is `live`、$name is the key of the live software.
            # The following FFMPEG commanf will tranform a input streaming to four different quality output streaming, and sent the output streaming to the RTMP application
            exec_push ffmpeg -i rtmp://localhost:1935/$app/$name
                        -c:v libx264 -c:a aac -b:v 800k  -b:a 128k  -vf "scale=w=640:h=360:force_original_aspect_ratio=decrease"  -tune zerolatency -preset superfast -crf 23 -f flv rtmp://localhost:1935/hls/$name_360p
                        -c:v libx264 -c:a aac -b:v 1400k  -b:a 384k -vf "scale=w=842:h=480:force_original_aspect_ratio=decrease"  -tune zerolatency -preset superfast -crf 23 -f flv rtmp://localhost:1935/hls/$name_480p
                        -c:v libx264 -c:a aac -b:v 2800k -b:a 384 -vf "scale=w=1280:h=720:force_original_aspect_ratio=decrease"  -tune zerolatency -preset superfast -crf 23 -f flv rtmp://localhost:1935/hls/$name_720p
                        -c:v libx264 -c:a aac -b:v 5000k -b:a 512k -vf "scale=w=1920:h=1080:force_original_aspect_ratio=decrease" -tune zerolatency -preset superfast -crf 23 -f flv rtmp://localhost:1935/hls/$name_1080p;
        }
        # for store the different quality
        application hls {
            live on; # allow input
            deny play all; 
            # allow the RTMP sent it by itself, it just receive the steaming for the RTMP streaming of the different quality.
            allow publish 127.0.0.1;
            deny publish all;
            hls on; # start HLS
            hls_fragment 3;
            hls_playlist_length 30;
            hls_path /hls/; # the path of the HLS
            hls_nested on; # Support the nested M3U8
            hls_continuous on; # continue the file number of the HLS
            hls_fragment_naming sequential; # The Method of the TS's file is use the Sequence number.
            hls_cleanup off; # Wehn the live broadcast start, it will be not clean the old files. (It just prevent there will no content when the live restart).
            # Focuse on the bandwidth for any quailty(The file of the M3U8 will define the suitable bandwidth fot each hls)
            # According to the input and produce the m3u8 file, if $name is `test`，and produce the `test.m3u8` in the ˋ\hls\ˋ path folder，and create the folder like `test_360p`
            hls_variant _1080p BANDWIDTH=5000000; # High bitrate, HD 720p resolution
            hls_variant _720p BANDWIDTH=2500000; # High bitrate, higher-than-SD resolution
            hls_variant _480p BANDWIDTH=1400000; # Medium bitrate, SD resolution
            hls_variant _360p BANDWIDTH=800000; # Low bitrate, sub-SD resolution
        }
    }
}

http {
    sendfile on;
    keepalive_timeout 65;
    include       /etc/nginx/mime.types; # import the default type of MIME
    default_type  application/octet-stream; # Default ContentType
    server {
        listen 80;
        # allow cross domain
        add_header 'Access-Control-Allow-Origin' '*' always;
        # setting route
        location /hls {
            # find the HLS folder
            alias /hls;
            # The file of M3U8 no CACHE
            location ~* \.m3u8$ {
                add_header 'Cache-Control' 'no-cache';
            }
        }
        # Setting the file of the index.html
        location /index.html {
            alias /etc/nginx/assets/index.html;
        }
    }
}
